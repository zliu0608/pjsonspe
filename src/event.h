#ifndef EVENT_H_
#define EVENT_H_

#ifdef _DEBUG
// windows memleak detect facility
#define _CRTDBG_MAP_ALLOC
#include <stdlib.h>
#include <crtdbg.h>
#endif

#include <limits.h>
#include <string>
#include "common.h"
#include "rapidjson/document.h"
#include "rapidjson/prettywriter.h"

using namespace rapidjson;

#define TIMESTAMP_MAX LLONG_MAX 



class Event {
public:
    enum EventType {
        TYPE_PLUS,    // plus data event
        TYPE_MINUS,   // minus data event
        TYPE_SYNC,    // sync control event (generated by source stream subscriber)
        TYPE_FLUSH,   // flush output control event (generated by window operator, used by group operator)
        TYPE_CLEAR,   // clear group context control event (generated by join operator in stream join with window case, used by group operator)
        TYPE_TRACE    // for trace purpose
    };

public:
  //  Event(Value* body) : pPayload_(body), type_(TYPE_PLUS), ts_(currentMicroSeconds()), refCount_(0) {
  //  };

    /**
     * construct a reusable event from a document pointer
     * note: the document point ownership will be moved to this Event object
     * This constructor is used by Group operator
     */
    Event(Document* body, EventType type, int64_t ts) : pPayload_(body), type_(type), ts_(ts), refCount_(0), reuse_(true) {
    };

    /**
     * update event payload document , type, timestamp etc. on a reusable event object
     */
    int update(Document* body, EventType type, int64_t ts) {
        if (!reuse_ || refCount_ != 0)
            return -1;

        if (pPayload_)
            delete pPayload_;
        pPayload_ = body;
        type_ = type;
        ts_ = ts;
        return 0;
    }


    Event(char* jsonText) : pPayload_(NULL), type_(TYPE_PLUS), ts_(currentMicroSeconds()), refCount_(0), reuse_(false) {
        Document* pDoc = new Document();
       // if (pDoc->ParseInsitu<0>(jsonText).HasParseError()) {
        if (pDoc->Parse<0>(jsonText).HasParseError()) {
            printf("error occured\n");
            delete pDoc;
            return;
        }

        pPayload_ = pDoc;
    };

    // constructor for creating a reusable Event object
    Event(): pPayload_(new Document()), type_(TYPE_PLUS), ts_(currentMicroSeconds()), refCount_(0), reuse_(true) {        
    }

    // update event is only allowed when the refcount = 0;
    // return 0 on a succesful update
    int update(const char* jsonText) {
        if (refCount_ != 0)
            return -1;

        // need to call destructor, otherwise reuse document object would cause memleak
        pPayload_->~Document();
        new(pPayload_) Document();

        // ParseInsitu seems to have better performance
        // if (pPayload_->ParseInsitu<0>(jsonText).HasParseError()) {
        if (pPayload_->Parse<0>(jsonText).HasParseError()) {
            printf("error occured\n");
            return -2;
        }
        ts_ = currentMicroSeconds();
        type_ = TYPE_PLUS;
        return 0;
    }

    // update event is only allowed when the refcount = 0;
    // return 0 on a succesful update
    int update(const char* jsonText, int64_t ts) {
        if (refCount_ != 0)
            return -1;

        // need to call destructor, otherwise reuse document object would cause memleak
        pPayload_->~Document();
        new(pPayload_) Document();

        // ParseInsitu seems to have better performance
        // if (pPayload_->ParseInsitu<0>(jsonText).HasParseError()) {
        if (pPayload_->Parse<0>(jsonText).HasParseError()) {
            printf("error occured\n");
            return -2;
        }
        ts_ = ts;
        type_ = TYPE_PLUS;
        return 0;
    }


    /* 
     * Update event payload is only allowed when the refcount = 0;
     *
     * @return 0 on a succesful update
     *
     * Note: updatePayload and updateTimestamp function are only used in
     * RbSourceStream::CompositeSubscriberHandler::onAvailable() call back 
     * timestamp is updated at publisher side,  event payload is updated 
     * at subscriber side.
     */
    int updatePayload(const char* jsonText) {
        if (refCount_ != 0)
            return -1;

        // need to call destructor, otherwise reuse document object would cause memleak
        pPayload_->~Document();
        new(pPayload_) Document();

        // ParseInsitu seems to have better performance
        // if (pPayload_->ParseInsitu<0>(jsonText).HasParseError()) {
        if (pPayload_->Parse<0>(jsonText).HasParseError()) {
            printf("error occured\n");
            return -2;
        }
        type_ = TYPE_PLUS;
        return 0;
    }

    /* 
     * Update event timestamp
     *
     * Note: updatePayload and updateTimestamp function are only used in
     * RbSourceStream::CompositeSubscriberHandler::onAvailable() call back 
     * timestamp is updated at publisher side,  event payload is updated 
     * at subscriber side.
     */
    void updateTimestamp(int64_t ts) {
        ts_ = ts;
    }

    virtual ~Event(){
        if (pPayload_) {
            delete pPayload_;
        }
    }

    virtual void incref(){
        atomicIncrement(&refCount_);
    }

    virtual void decref(){
        if (0 == atomicDecrement(&refCount_) ) {
            // destroy the event only when it's not reusable.
            if (!reuse_)
                delete this;
        }
    }

    virtual Value* getPayload() {
        return pPayload_;
    }

    virtual int64_t getTimestamp() {
        return ts_;
    }

    virtual EventType getType() {
        return type_;
    }

    virtual bool isDataEvent() {
        EventType t = getType();
        return (t == TYPE_PLUS || t == TYPE_MINUS);
    }

    virtual bool isDataOrSyncEvent() {
        EventType t = getType();
        return (t == TYPE_PLUS || t == TYPE_MINUS || t == TYPE_SYNC);
    }

    virtual bool isFlushEvent() {
        return (TYPE_FLUSH == getType());
    }

    virtual bool isClearEvent() {
        return (TYPE_CLEAR == getType());
    }
private:
    Document* pPayload_;  // event payload
    int64_t ts_;          // event timestamp
    EventType type_;      // event type
    bool reuse_;          // flag for reuse
    long volatile refCount_;     // reference count
};


/**
 *  Event used in between operators
 */
class IntermediateEvent : public Event {
public:
    IntermediateEvent(Value* body, EventType type, int64_t ts) : pValue_(body), type_(type), ts_(ts) {
    }; 
    
    IntermediateEvent() : pValue_(NULL), type_(TYPE_PLUS), ts_(0) {
    }; 
    
    virtual ~IntermediateEvent() {
        // no need to delete/free pValue_, since it's computed out by upper stream operator,
        // and then will be passed to downstream operator in the same thread,  the originating operator 
        // is responsible for deleting the payload along with the Event wrapper object
    }

    void setEvent(Value* body, EventType type, int64_t ts) {
        pValue_ = body;
        type_ = type;
        ts_ = ts;
    }

    virtual Value* getPayload() {
        return pValue_;
    }

    virtual int64_t getTimestamp() {
        return ts_;
    }

    virtual EventType getType() {
        return type_;
    }
private:
    Value* pValue_;       // event payload
    int64_t ts_;          // event timestamp
    EventType type_;      // event type
};



/**
 * A stream implementation for serializing event json payload
 * this class should be used along with Json writer classes (Writer or PrettyWriter)
 */
class JsonStringOutputStream {
public:
    /**
     * Constructor
     */
    JsonStringOutputStream() : prettyWriter_(NULL), plainWriter_(NULL) {
        s_.reserve(255);
        prettyWriter_ = new PrettyWriter<JsonStringOutputStream>(*this);
        plainWriter_ = new Writer<JsonStringOutputStream>(*this);
    }

    /**
     * Destructor
     */
    ~JsonStringOutputStream() {
        if (prettyWriter_)
            delete prettyWriter_;
        if (plainWriter_)
            delete plainWriter_;
    }

    // not implement
	char* PutBegin() { return 0; }
    // not implement
    size_t PutEnd(char*) { return 0; }    
    // clear up
    void Reset() {s_ = "";}    
    // write one char
    void Put(char c) { s_.append(1, c);}

    /**
     * serialize event payload (json) into a string
     *
     * @param payload  pointer to a JSON Value object to be serialized
     * @param prettyFormat true to serialze with proper indentation and spaces
     * @return string contains the serialization result
     */
    const std::string& serialize(Value* payload, bool prettyFormat = false) {
        Reset();
        if (payload == NULL)
            return s_;

        // handle non-object/non-array value too.
        switch(payload->GetType()) {
        case kNullType:
            WriteNull();
            break;
        case kObjectType:
        case kArrayType:
            if (prettyFormat) {
                payload->Accept(*prettyWriter_);
            }
            else {
                payload->Accept(*plainWriter_);
            }
            break;
        case kFalseType:
            WriteBool(false);
            break;
        case kTrueType:
            WriteBool(true);
            break;
        case kStringType:                
            WriteString(payload->GetString(), payload->GetStringLength());
            break;
        case kNumberType:
            if (payload->IsInt()) {
                WriteInt(payload->GetInt()); 
            }
            else if (payload->IsUint()) {
                WriteUint(payload->GetUint()); 
            }
            else if (payload->IsInt64()) {
                WriteInt64(payload->GetInt64()); 
            }
            else if (payload->IsUint64()) {
                WriteUint64(payload->GetUint64()); 
            }
            else {
                WriteDouble(payload->GetDouble()); 
            }
            break;
        }// end switch    
        return s_;
    }

    /**
     * serialize event payload (json) into a string
     *
     * @param evt  event to be serialized
     * @param prettyFormat true to serialze with proper indentation and spaces
     * @return string contains the serialization result
     */
    const std::string& serialize(Event& evt, bool prettyFormat = false) {
        Value* payload = evt.getPayload();
        return serialize(payload);
    }

    /**
     * Get the resulting string
     *
     * @return the serialized string
     */
    const std::string& getString() {
        return s_;
    }
private:
    std::string s_;
    PrettyWriter<JsonStringOutputStream> *prettyWriter_;
    Writer<JsonStringOutputStream> *plainWriter_;

protected:
	void WriteNull()  {
		Put('n'); Put('u'); Put('l'); Put('l');
	}

	void WriteBool(bool b)  {
		if (b) {
			Put('t'); Put('r'); Put('u'); Put('e');
		}
		else {
			Put('f'); Put('a'); Put('l'); Put('s'); Put('e');
		}
	}

	void WriteInt(int i) {
		if (i < 0) {
			Put('-');
			i = -i;
		}
		WriteUint((unsigned)i);
	}

	void WriteUint(unsigned u) {
		char buffer[10];
		char *p = buffer;
		do {
			*p++ = (u % 10) + '0';
			u /= 10;
		} while (u > 0);

		do {
			--p;
			Put(*p);
		} while (p != buffer);
	}

	void WriteInt64(int64_t i64) {
		if (i64 < 0) {
			Put('-');
			i64 = -i64;
		}
		WriteUint64((uint64_t)i64);
	}

	void WriteUint64(uint64_t u64) {
		char buffer[20];
		char *p = buffer;
		do {
			*p++ = char(u64 % 10) + '0';
			u64 /= 10;
		} while (u64 > 0);

		do {
			--p;
			Put(*p);
		} while (p != buffer);
	}

	//! \todo Optimization with custom double-to-string converter.
	void WriteDouble(double d) {
		char buffer[100];
#if _MSC_VER
		int ret = sprintf_s(buffer, sizeof(buffer), "%g", d);
#else
		int ret = snprintf(buffer, sizeof(buffer), "%g", d);
#endif
		RAPIDJSON_ASSERT(ret >= 1);
		for (int i = 0; i < ret; i++)
			Put(buffer[i]);
	}

	void WriteString(const char* str, SizeType length)  {
		static const char hexDigits[] = "0123456789ABCDEF";
		static const char escape[256] = {
#define Z16 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
			//0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
			'u', 'u', 'u', 'u', 'u', 'u', 'u', 'u', 'b', 't', 'n', 'u', 'f', 'r', 'u', 'u', // 00
			'u', 'u', 'u', 'u', 'u', 'u', 'u', 'u', 'u', 'u', 'u', 'u', 'u', 'u', 'u', 'u', // 10
			  0,   0, '"',   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, // 20
			Z16, Z16,																		// 30~4F
			  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,'\\',   0,   0,   0, // 50
			Z16, Z16, Z16, Z16, Z16, Z16, Z16, Z16, Z16, Z16								// 60~FF
#undef Z16
		};

		Put('\"');
		for (const char* p = str; p != str + length; ++p) {
			if ((sizeof(char) == 1 || *p < 256) && escape[(unsigned char)*p])  {
				Put('\\');
				Put(escape[(unsigned char)*p]);
				if (escape[(unsigned char)*p] == 'u') {
					Put('0');
					Put('0');
					Put(hexDigits[(*p) >> 4]);
					Put(hexDigits[(*p) & 0xF]);
				}
			}
			else
				Put(*p);
		}
		Put('\"');
	}

};


#endif